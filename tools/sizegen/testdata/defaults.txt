// This file was generated by sizegen. DO NOT EDIT.

package testdata

import (
	"reflect"
	"unsafe"
)

// Constants for the byte size of each Go numeric type.
const (
	intBytes        = uint64(unsafe.Sizeof(int(0)))
	uintBytes       = uint64(unsafe.Sizeof(uint(0)))
	uintptrBytes    = uint64(unsafe.Sizeof(uintptr(0)))
	boolBytes       = uint64(unsafe.Sizeof(bool(false)))
	int8Bytes       = uint64(unsafe.Sizeof(int8(0)))
	int16Bytes      = uint64(unsafe.Sizeof(int16(0)))
	int32Bytes      = uint64(unsafe.Sizeof(int32(0)))
	int64Bytes      = uint64(unsafe.Sizeof(int64(0)))
	uint8Bytes      = uint64(unsafe.Sizeof(uint8(0)))
	uint16Bytes     = uint64(unsafe.Sizeof(uint16(0)))
	uint32Bytes     = uint64(unsafe.Sizeof(uint32(0)))
	uint64Bytes     = uint64(unsafe.Sizeof(uint64(0)))
	float32Bytes    = uint64(unsafe.Sizeof(float32(0)))
	float64Bytes    = uint64(unsafe.Sizeof(float64(0)))
	complex64Bytes  = uint64(unsafe.Sizeof(complex64(0)))
	complex128Bytes = uint64(unsafe.Sizeof(complex128(0)))
	byteBytes       = uint8Bytes
	runeBytes       = int32Bytes
)

// kindBytes maps each numeric reflect.Kind to the number of bytes it takes.
// Non-numeric kinds and aliases are not included.
var kindBytes = map[reflect.Kind]uint64{
	reflect.Int:        intBytes,
	reflect.Uint:       uintBytes,
	reflect.Uintptr:    uintptrBytes,
	reflect.Bool:       boolBytes,
	reflect.Int8:       int8Bytes,
	reflect.Int16:      int16Bytes,
	reflect.Int32:      int32Bytes,
	reflect.Int64:      int64Bytes,
	reflect.Uint8:      uint8Bytes,
	reflect.Uint16:     uint16Bytes,
	reflect.Uint32:     uint32Bytes,
	reflect.Uint64:     uint64Bytes,
	reflect.Float32:    float32Bytes,
	reflect.Float64:    float64Bytes,
	reflect.Complex64:  complex64Bytes,
	reflect.Complex128: complex128Bytes,
}
